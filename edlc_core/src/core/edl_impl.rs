/*
 *    Copyright 2025 Adrian Paskert
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

use crate::core::edl_error::EdlError;
use crate::core::edl_fn::{EdlCompilerState, EdlFnArgument, EdlFnArgumentValues, EdlFnSignature, FnArgumentConstraints};
use crate::core::edl_param_env::{EdlParamStack, EdlParameterDef, InsertParameterEnv};
use crate::core::edl_trait::EdlTraitId;
use crate::core::edl_type::{EdlEnvId, EdlFnInstance, EdlMaybeType, EdlTraitInstance, EdlTypeId, EdlTypeInstance, EdlTypeRegistry, ReplaceEnv, StackReplacements};
use crate::core::index_map::IndexMap;
use crate::core::type_analysis::{EnvConstraint, EnvConstraintStack, ExportedSnapshot, Infer, InferAt, InferEq, InferError, InferProvider, InferState, NodeId, SigConstraint, TypeUid};
use crate::resolver::{QualifierName, ScopeId};
use std::collections::{HashMap, HashSet};
use std::error::Error;
use std::fmt::{Display, Formatter};

pub struct EdlTraitImpl {
    pub trait_id: EdlTraitId,
    pub trait_params: EdlParameterDef,
    pub im: EdlImpl,
}

/// A trait implementation for EDL traits.
pub struct EdlImpl {
    pub associated: Vec<AssociatedType>,
    pub fns: HashMap<String, EdlTypeId>,
    /// The implementation environment is used to define generic types and constants that can be used within the
    /// scope of the implementation.
    pub env: EdlEnvId,
    /// The `base` type is the type that the implementation is linked to.
    /// Generic parameters that link to the implementation environment `env` can be used anywhere in its definition.
    /// Since implementations are **top-level items** and nesting implementations into other parameter environments
    /// is forbidden, the base type should __not__ contain **any** other generic parameters.
    pub base: EdlTypeInstance,
}

pub struct AssociatedType {
    pub name: String,
    pub ty: EdlTypeInstance,
}

#[derive(Debug)]
pub struct EdlFnCallInfo {
    pub id: EdlTypeId,
    pub ret_buf: EdlMaybeType,
    pub stack: EdlParamStack,
    pub env_replacements: StackReplacements,
    pub base: Option<EdlTypeInstance>,
    pub sig: EdlFnSignature,
}

/// Call constraints essentially implement the type inferer constraints generated by a function
/// call.
#[derive(Debug)]
pub struct CallConstraint {
    pub id: EdlTypeId,
    pub sig: SigConstraint,
    pub base: Option<TypeUid>,
    pub snapshot: ExportedSnapshot,
}

#[derive(Debug)]
/// A constraint error is an error that may be generated while trying to resolve type constraints
/// for the type inferer while resolving a function or method call.
pub enum FnConstraintError {
    NoSuchFunction(String),
    EdlError(EdlTypeId, EdlError),
    ConstraintMismatch(EdlTypeId, InferError),
    GenericTypeHintError(EdlTypeId, String),
}

impl From<(EdlTypeId, FnConstraintError)> for FnConstraintError {
    fn from(value: (EdlTypeId, FnConstraintError)) -> Self {
        value.1
    }
}

impl From<(EdlTypeId, InferError)> for FnConstraintError {
    fn from((id, value): (EdlTypeId, InferError)) -> Self {
        FnConstraintError::ConstraintMismatch(id, value)
    }
}

impl From<(EdlTypeId, EdlError)> for FnConstraintError {
    fn from((id, value): (EdlTypeId, EdlError)) -> Self {
        FnConstraintError::EdlError(id, value)
    }
}

#[derive(Debug)]
pub struct ResolveFail<T: EdlFnArgument> {
    pub id: EdlTypeId,
    pub sig: EdlFnSignature,
    pub stack: EdlParamStack,
    pub env_replacements: StackReplacements,
    pub base_self: EdlTypeInstance,
    pub base: Option<EdlTypeInstance>,
    pub args: EdlFnArgumentValues<T>
}

#[derive(Debug)]
pub enum FnResolveError<T: EdlFnArgument, E: Error> {
    EarlyExit(E),
    Base(E, ResolveFail<T>),
    Signature(E, ResolveFail<T>),
    Other(String, ResolveFail<T>),
}

impl<T: EdlFnArgument, E: Error> Display for FnResolveError<T, E> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EarlyExit(err) => {
                write!(f, "{err}")
            }
            Self::Base(err, _info ) => {
                write!(f, "{err}")
            }
            Self::Signature(err, _info) => {
                write!(f, "{err}")
            }
            Self::Other(err, _info) => {
                write!(f, "{err}")
            }
        }
    }
}

impl<T: EdlFnArgument, E: Error> Error for FnResolveError<T, E> {}

impl<T: EdlFnArgument, E: Error> From<E> for FnResolveError<T, E> {
    fn from(value: E) -> Self {
        FnResolveError::EarlyExit(value)
    }
}





impl EdlFnCallInfo {
    /// Returns the function instance that this function call info eludes too.
    pub fn fn_instance(&self) -> EdlFnInstance {
        EdlFnInstance {
            func: self.id.clone(),
            param: self.stack.clone(),
            associated_ty: self.base.clone(),
        }
    }
}

macro_rules! roll_back_err(
    (fn $x:expr, $inferer:expr, $snapshot:expr) => (
        match $x {
            Ok(val) => val,
            Err(err) => {
                $inferer.roll_back_to($snapshot);
                return Err(err.into());
            }
        }
    );
    ($x:expr, $inferer:expr, $snapshot:expr, $fn_id:expr) => (
        match $x {
            Ok(val) => val,
            Err(err) => {
                $inferer.roll_back_to($snapshot);
                return Err(($fn_id, err).into());
            }
        }
    )
);

impl EdlImpl {
    pub fn contains_fn(&self, fn_id: EdlTypeId) -> bool {
        self.fns.iter().any(|(_key, value)| *value == fn_id)
    }

    pub fn find_constraint<I: InferProvider, GenHint: Fn(EdlEnvId, &mut I) -> Result<GenericTypeHints, String>>(
        &self,
        name: &str,
        args: &FnArgumentConstraints,
        base: TypeUid,
        generic_type_hints: Option<&GenHint>,
        infer: &mut I,
        state: &mut InferState,
        node: NodeId,
    ) -> Result<CallConstraint, FnConstraintError> {
        let Some(&fn_id) = self.fns.get(name) else {
            return Err(FnConstraintError::NoSuchFunction(name.to_string()));
        };

        let mut inferer = infer.infer_from(state);
        let snapshot = inferer.snapshot();

        // let fn_id = *roll_back_err!(fn self.fns.get(name)
        //     .ok_or(FnConstraintError::NoSuchFunction(name.to_string())), inferer, snapshot);
        let sig = roll_back_err!(inferer.type_reg.get_fn_signature(fn_id), inferer, snapshot, fn_id);
        assert_eq!(sig.name, name);

        // create base stack
        let con = roll_back_err!(EnvConstraint::new(self.env, &mut inferer.at(node)), inferer, snapshot, fn_id);
        let mut stack = EnvConstraintStack::default();
        stack.insert(con);
        roll_back_err!(<InferAt as InferEq<TypeUid, EdlTypeInstance>>::eq(&mut inferer.at_env(node, &stack), &base, &self.base), inferer, snapshot, fn_id);

        // adapt base signature
        let sig_constraint = roll_back_err!(SigConstraint::from_signature(node, fn_id, sig, &mut inferer, &mut stack), inferer, snapshot, fn_id);
        if let Some(hints) = generic_type_hints {
            let env = sig.env;
            let hints = hints(env, infer)
                .map_err(|err| FnConstraintError::GenericTypeHintError(fn_id, err));

            inferer = infer.infer_from(state); // re-create inferer for borrowing rules
            let hints = roll_back_err!(hints, inferer, snapshot, fn_id);
            roll_back_err!(sig_constraint.hint_generics(&hints.params, &mut inferer, node), inferer, snapshot, fn_id);
        }
        inferer = infer.infer_from(state);
        roll_back_err!(sig_constraint.adapt(node, &args.args, &args.ret, &mut inferer), inferer, snapshot, fn_id);

        let snapshot = inferer.roll_back_to(snapshot);
        Ok(CallConstraint {
            id: fn_id,
            sig: sig_constraint,
            base: Some(base),
            snapshot,
        })
    }

    pub fn find_trait_constraint<I: InferProvider, GenHint: Fn(EdlEnvId, &mut I) -> Result<GenericTypeHints, String>>(
        &self,
        name: &str,
        args: &FnArgumentConstraints,
        generic_type_hints: Option<&GenHint>,
        infer: &mut I,
        state: &mut InferState,
        node: NodeId,
    ) -> Result<CallConstraint, FnConstraintError> {
        let Some(&fn_id) = self.fns.get(name) else {
            return Err(FnConstraintError::NoSuchFunction(name.to_string()));
        };

        let mut inferer = infer.infer_from(state);
        let snapshot = inferer.snapshot();

        // let fn_id = *roll_back_err!(fn self.fns.get(name)
        //     .ok_or(FnConstraintError::NoSuchFunction(name.to_string())), inferer, snapshot);
        let sig = roll_back_err!(inferer.type_reg.get_fn_signature(fn_id), inferer, snapshot, fn_id);
        assert_eq!(sig.name, name);

        // create base stack
        let con = roll_back_err!(EnvConstraint::new(self.env, &mut inferer.at(node)), inferer, snapshot, fn_id);
        let mut stack = EnvConstraintStack::default();
        stack.insert(con);
        let base_ty = roll_back_err!(inferer.at_env(node, &stack).insert_type_instance(&self.base), inferer, snapshot, fn_id);

        // adapt base signature
        let sig_constraint = roll_back_err!(SigConstraint::from_signature(node, fn_id, sig, &mut inferer, &mut stack), inferer, snapshot, fn_id);
        if let Some(hints) = generic_type_hints {
            let env = sig.env;
            let hints = hints(env, infer)
                .map_err(|err| FnConstraintError::GenericTypeHintError(fn_id, err));
            inferer = infer.infer_from(state);
            let hints = roll_back_err!(hints, inferer, snapshot, fn_id);
            roll_back_err!(sig_constraint.hint_generics(&hints.params, &mut inferer, node), inferer, snapshot, fn_id);
        }
        inferer = infer.infer_from(state);
        roll_back_err!(sig_constraint.adapt(node, &args.args, &args.ret, &mut inferer), inferer, snapshot, fn_id);

        let snapshot = inferer.roll_back_to(snapshot);
        Ok(CallConstraint {
            id: fn_id,
            sig: sig_constraint,
            base: Some(base_ty),
            snapshot,
        })
    }

    pub fn find_parameter_stack<State: EdlCompilerState>(
        &self,
        fn_id: EdlTypeId,
        fn_param: EdlParameterDef,
        mut associated: EdlTypeInstance,
        state: &mut State,
    ) -> Result<(EdlParamStack, StackReplacements), State::Error> {
        assert!(self.contains_fn(fn_id));

        let mut stack  = self.gen_base_stack(state.type_registry_mut())
            .map_err(|err| state.format_err(err))?;
        stack.insert(fn_param, state.type_registry_mut())
            .map_err(|err| state.format_err(err))?;

        let (stack, replacements) = stack;
        state.put_stack(stack)?;

        // adapt to specified base type
        let mut base = self.base.clone();
        base.replace_env(&replacements, state.type_registry());

        state.adapt_other_type(&base, &mut associated)?;
        let stack = state.take_stack().unwrap();
        // check if the stack is fully resolved
        if !stack.is_fully_resolved() {
            return Err(state.format_err(EdlError::E055(stack)));
        }
        Ok((stack, replacements))
    }

    fn gen_base_stack(&self, type_reg: &mut EdlTypeRegistry) -> Result<(EdlParamStack, StackReplacements), EdlError> {
        let mut stack = (EdlParamStack::default(), StackReplacements::default());
        stack.insert_new(self.env, type_reg)?;
        Ok(stack)
    }
}


#[derive(Debug, Default, Clone, Copy, PartialOrd, PartialEq, Ord, Eq, Hash)]
pub struct EdlModuleId(usize);

/// Implementations live in modules.
/// Therefore, the implementation registry requires a list of loaded modules to determine which implementations can
/// be accessed by the function resolver.
#[derive(Default)]
struct EdlImplModule {
    impls: Vec<EdlImpl>,
    trait_impls: Vec<EdlTraitImpl>,

    impl_functions: HashMap<String, Vec<usize>>,
    trait_functions: HashMap<String, Vec<usize>>,
}

pub type ModuleStack = Vec<EdlModuleId>;

#[derive(Default)]
pub struct EdlImplRegistry {
    modules: IndexMap<EdlImplModule>,

    impl_functions: HashMap<String, HashSet<EdlModuleId>>,
    trait_functions: HashMap<EdlTraitId, HashSet<EdlModuleId>>,
}

impl EdlImplModule {
    pub fn insert_impl(&mut self, func_impl: EdlImpl) {
        let idx = self.impls.len();
        for name in func_impl.fns.keys() {
            self.impl_functions.entry(name.clone()).or_insert(vec![]).push(idx);
        }
        self.impls.push(func_impl);
    }

    pub fn insert_trait_impl(&mut self, func_impl: EdlTraitImpl) {
        let idx = self.trait_impls.len();
        for name in func_impl.im.fns.keys() {
            self.trait_functions.entry(name.clone()).or_insert(vec![]).push(idx);
        }
        self.trait_impls.push(func_impl)
    }

    pub fn find_parameter_stack<State: EdlCompilerState>(
        &self,
        fn_id: EdlTypeId,
        fn_param: EdlParameterDef,
        associated: EdlTypeInstance,
        state: &mut State,
    ) -> Result<Option<(EdlParamStack, StackReplacements)>, State::Error> {
        let im = self.impls.iter()
            .find(move |im| im.contains_fn(fn_id));
        if let Some(im) = im {
            return Ok(Some(im.find_parameter_stack(fn_id, fn_param, associated, state)?))
        }

        let tr = self.trait_impls.iter()
            .find(move |im| im.im.contains_fn(fn_id));
        if let Some(im) = tr {
            Ok(Some(im.im.find_parameter_stack(fn_id, fn_param, associated, state)?))
        } else {
            Ok(None)
        }
    }

    pub fn gather_constraint_candidates<I: InferProvider, GenHint: Fn(EdlEnvId, &mut I) -> Result<GenericTypeHints, String>>(
        &self,
        name: &str,
        base: &TypeUid,
        args: &FnArgumentConstraints,
        generic_type_hints: Option<&GenHint>,
        infer: &mut I,
        state: &mut InferState,
        node: NodeId,
    ) -> (Vec<CallConstraint>, Vec<FnConstraintError>) {
        // match basic impls
        let mut candidates = Vec::new();
        let mut failed_candidates = Vec::new();

        // match basic impls
        if let Some(indices) = self.impl_functions.get(name) {
            for index in indices {
                let im = &self.impls[*index];
                match im.find_constraint(name, args, *base, generic_type_hints, infer, state, node) {
                    Ok(f) => candidates.push(f),
                    Err(FnConstraintError::NoSuchFunction(_)) => (),
                    Err(err) => failed_candidates.push(err),
                }
            }
        }

        // match trait impls
        if let Some(indices) = self.trait_functions.get(name) {
            for index in indices {
                let im = &self.trait_impls[*index];
                match im.im.find_constraint(name, args, *base, generic_type_hints, infer, state, node) {
                    Ok(f) => candidates.push(f),
                    Err(FnConstraintError::NoSuchFunction(_)) => (),
                    Err(err) => failed_candidates.push(err),
                }
            }
        }
        (candidates, failed_candidates)
    }

    pub fn gather_trait_constraints<I: InferProvider, GenHint: Fn(EdlEnvId, &mut I) -> Result<GenericTypeHints, String>>(
        &self,
        trait_id: &EdlTraitInstance,
        name: &str,
        args: &FnArgumentConstraints,
        generic_type_hints: Option<&GenHint>,
        infer: &mut I,
        state: &mut InferState,
        node: NodeId,
    ) -> (Vec<CallConstraint>, Vec<FnConstraintError>) {
        let mut candidates = Vec::new();
        let mut failed_candidates = Vec::new();

        if let Some(indices) = self.trait_functions.get(name) {
            for index in indices {
                let im = &self.trait_impls[*index];
                if im.trait_id != trait_id.trait_id {
                    continue;
                }
                // todo implement matching of parameters from trait instance

                match im.im.find_trait_constraint(name, args, generic_type_hints, infer, state, node) {
                    Ok(f) => candidates.push(f),
                    Err(FnConstraintError::NoSuchFunction(_)) => (),
                    Err(err) => failed_candidates.push(err),
                }
            }
        }
        (candidates, failed_candidates)
    }
}

impl EdlImplRegistry {
    /// Inserts an implementation into the module associated with the specified module id.
    pub fn insert_impl(&mut self, module: EdlModuleId, func_impl: EdlImpl) {
        // insert fast lookup
        for name in func_impl.fns.keys() {
            self.impl_functions.entry(name.clone()).or_insert(HashSet::new()).insert(module);
        }

        if let Some(m) = self.modules.view_mut(module.0).get_mut() {
            m.insert_impl(func_impl);
        } else {
            let mut m = EdlImplModule::default();
            m.insert_impl(func_impl);
            self.modules.view_mut(module.0).set(m);
        }
    }

    pub fn insert_trait_impl(&mut self, module: EdlModuleId, trait_impl: EdlTraitImpl) {
        // insert fast lookup
        for name in trait_impl.im.fns.keys() {
            self.impl_functions.entry(name.clone()).or_insert(HashSet::new()).insert(module);
        }
        self.trait_functions.entry(trait_impl.trait_id).or_insert(HashSet::new()).insert(module);

        if let Some(m) = self.modules.view_mut(module.0).get_mut() {
            m.insert_trait_impl(trait_impl);
        } else {
            let mut m = EdlImplModule::default();
            m.insert_trait_impl(trait_impl);
            self.modules.view_mut(module.0).set(m);
        }
    }

    /// Finds the parameter stack for a function id `fn_id` with the function parameter definitions
    /// `fn_param` and the associated type `associated`.
    /// For this method to work, both the function parameter definitions, **and** the associated
    /// type should be fully resolved.
    /// This method can be useful in building function instances were the full parameter stack is
    /// not provided, but `fn_id`, `fn_param` and `associated` are present.
    pub fn find_parameter_stack<State: EdlCompilerState>(
        &self,
        fn_id: EdlTypeId,
        fn_param: EdlParameterDef,
        associated: EdlTypeInstance,
        state: &mut State,
    ) -> Result<(EdlParamStack, StackReplacements), State::Error> {
        for (_idx, module) in self.modules.iter() {
            if let Some(res) = module.find_parameter_stack(
                fn_id, fn_param.clone(), associated.clone(), state)? {
                return Ok(res);
            }
        }
        Err(state.format_err(EdlError::E059(fn_id, fn_param, associated)))
    }

    pub fn gather_constraints<I: InferProvider, GenHint: Fn(EdlEnvId, &mut I) -> Result<GenericTypeHints, String>>(
        &self,
        name: &str,
        base: &TypeUid,
        args: &FnArgumentConstraints,
        generic_type_hints: Option<&GenHint>,
        infer: &mut I,
        state: &mut InferState,
        node: NodeId,
    ) -> (Vec<CallConstraint>, Vec<FnConstraintError>) {
        let Some(candidates) = self.impl_functions.get(name) else {
            return (vec![], vec![]);
        };

        candidates.into_iter()
            .flat_map(|idx| self.modules.get(idx.0))
            .map(|module| module.gather_constraint_candidates(name, base, args, generic_type_hints, infer, state, node))
            .reduce(|(mut lhs, mut lhs2), (mut rhs, mut rhs2)| {
                lhs.append(&mut rhs);
                lhs2.append(&mut rhs2);
                (lhs, lhs2)
            })
            .unwrap_or_default()
    }

    pub fn gather_trait_constraints<I: InferProvider, GenHint: Fn(EdlEnvId, &mut I) -> Result<GenericTypeHints, String>>(
        &self,
        trait_id: &EdlTraitInstance,
        name: &str,
        args: &FnArgumentConstraints,
        generic_type_hints: Option<&GenHint>,
        infer: &mut I,
        state: &mut InferState,
        node: NodeId,
    ) -> (Vec<CallConstraint>, Vec<FnConstraintError>) {
        let Some(candidates) = self.trait_functions.get(&trait_id.trait_id) else {
            return (vec![], vec![]);
        };

        candidates.iter()
            .flat_map(|idx| self.modules.get(idx.0))
            .map(|module| module.gather_trait_constraints(trait_id, name, args, generic_type_hints, infer, state, node))
            .reduce(|(mut lhs, mut lhs2 ), (mut rhs, mut rhs2)| {
                lhs.append(&mut rhs);
                lhs2.append(&mut rhs2);
                (lhs, lhs2)
            })
            .unwrap_or_default()
    }
}

#[derive(Debug)]
pub enum CallResolveError {
    NoSuchFunction,
    NoSuchTraitFunction,
    NoSuchMethod,
    NoSuchTraitMethod,
    TooManyTraitFunctions(Vec<CallConstraint>),
    TooManyMethods(Vec<CallConstraint>),
    TooManyTraitMethods(Vec<CallConstraint>),
    InvalidFunctionCall(FnConstraintError),
    InvalidTraitFunctionCall(FnConstraintError),
    InvalidMethodCall(FnConstraintError),
    InvalidTraitMethodCall(FnConstraintError),
    MultiInvalidTraitFunctionCall(Vec<FnConstraintError>),
    MultiInvalidMethodCall(Vec<FnConstraintError>),
    MultiInvalidTraitMethodCall(Vec<FnConstraintError>),
}


#[derive(Debug, Clone, PartialEq)]
/// Explicit type hints for generic parameter lists.
pub struct GenericTypeHints {
    pub params: EdlParameterDef,
}

#[derive(Debug, Clone, PartialEq)]
struct ResolveSuccess {
    fn_id: EdlTypeId,
    sig: SigConstraint,
    base: Option<TypeUid>,
}

#[derive(Debug, Clone, PartialEq)]
enum CallType {
    Method(TypeUid, String),
    Function(QualifierName),
}

#[derive(Debug, Clone, PartialEq)]
pub struct CallResolver {
    scope: ScopeId,
    base: CallType,
    trait_id: Option<EdlTraitInstance>,

    pub args: FnArgumentConstraints,
    generic_type_hints: Option<GenericTypeHints>,

    res: Option<ResolveSuccess>,
}

/// Returns the resolution facts for a plane function call.
/// This is used to generate compiler reports
pub struct PlaneFunctionFacts {
    pub name: QualifierName,
    pub args: FnArgumentConstraints,
}

impl ResolutionFact for PlaneFunctionFacts {}

pub struct TraitFunctionFacts {
    pub name: String,
    pub trait_id: EdlTraitInstance,
    pub args: FnArgumentConstraints,
}

impl ResolutionFact for TraitFunctionFacts {}

pub struct MethodFacts {
    pub name: String,
    pub base: TypeUid,
    pub args: FnArgumentConstraints,
}

impl ResolutionFact for MethodFacts {}

pub struct TraitMethodFacts {
    pub name: String,
    pub trait_id: EdlTraitInstance,
    pub base: TypeUid,
    pub args: FnArgumentConstraints,
}

impl ResolutionFact for TraitMethodFacts {}

pub trait ResolutionFact {}

pub trait GatherFacts<F: ResolutionFact> {
    /// Gathers facts to generate a compiler report in case of an error.
    /// Specific `Fact` implementations may be only gathered for specific states of the resolver.
    /// If a fact cannot be gathered, `None` is returned.
    fn gather_facts(&self) -> Option<F>;
}

impl GatherFacts<PlaneFunctionFacts> for CallResolver {
    fn gather_facts(&self) -> Option<PlaneFunctionFacts> {
        let CallType::Function(name) = &self.base else {
            return None;
        };
        if self.trait_id.is_some() {
            return None;
        }
        Some(PlaneFunctionFacts {
            name: name.clone(),
            args: self.args.clone(),
        })
    }
}

impl GatherFacts<TraitFunctionFacts> for CallResolver {
    fn gather_facts(&self) -> Option<TraitFunctionFacts> {
        let CallType::Function(name) = &self.base else {
            return None;
        };
        if name.len() > 1 {
            return None;
        }
        let trait_id = self.trait_id.clone()?;
        Some(TraitFunctionFacts {
            name: name.first()?.to_string(),
            args: self.args.clone(),
            trait_id,
        })
    }
}

impl GatherFacts<MethodFacts> for CallResolver {
    fn gather_facts(&self) -> Option<MethodFacts> {
        let CallType::Method(base, name) = &self.base else {
            return None;
        };
        if self.trait_id.is_some() {
            return None;
        }
        Some(MethodFacts {
            name: name.clone(),
            base: *base,
            args: self.args.clone(),
        })
    }
}

impl GatherFacts<TraitMethodFacts> for CallResolver {
    fn gather_facts(&self) -> Option<TraitMethodFacts> {
        let CallType::Method(base, name) = &self.base else {
            return None;
        };
        let trait_id = self.trait_id.clone()?;
        Some(TraitMethodFacts {
            name: name.clone(),
            base: *base,
            trait_id,
            args: self.args.clone(),
        })
    }
}

impl CallResolver {
    pub fn is_resolved(&self) -> bool {
        self.res.is_some()
    }

    pub fn is_comptime(&self) -> bool {
        self.res.as_ref().map(|v| v.sig.comptime).unwrap_or(false)
    }

    pub fn associate(&self) -> Option<TypeUid> {
        match &self.base {
            CallType::Method(associate, _) => Some(*associate),
            _ => None,
        }
    }

    pub fn associate_function(associate: TypeUid, name: String, args: FnArgumentConstraints, scope: ScopeId) -> Self {
        CallResolver {
            base: CallType::Method(associate, name),
            trait_id: None,
            args,
            generic_type_hints: None,
            res: None,
            scope,
        }
    }

    pub fn function(name: QualifierName, args: FnArgumentConstraints, scope: ScopeId) -> Self {
        CallResolver {
            base: CallType::Function(name),
            trait_id: None,
            args,
            generic_type_hints: None,
            res: None,
            scope,
        }
    }

    pub fn with_trait(&mut self, trait_id: EdlTraitInstance) -> &mut Self {
        self.trait_id = Some(trait_id);
        self
    }

    pub fn with_generic_type_hints(&mut self, hints: GenericTypeHints) -> &mut Self {
        self.generic_type_hints = Some(hints);
        self
    }

    pub fn resolve<I: InferProvider, GenHint: Fn(EdlEnvId, &mut I) -> Result<GenericTypeHints, String>>(
        &mut self,
        infer: &mut I,
        state: &mut InferState,
        impl_reg: &EdlImplRegistry,
        generic_hints: Option<&GenHint>,
        node: NodeId,
    ) -> Result<(), CallResolveError> {
        let candidate = match &self.base {
            CallType::Method(base, name) => {
                // resolve as method call
                if let Some(trait_id) = self.trait_id.as_ref() {
                    // resolve as trait function
                    infer.change_scope(self.scope);
                    let (mut constraints, mut failed_constraints) = impl_reg.gather_trait_constraints(
                        trait_id, name, &self.args, generic_hints, infer, state, node);
                    if constraints.len() == 1 {
                        constraints.pop().unwrap()
                    } else if constraints.len() > 1 {
                        // found too many candidates
                        return Err(CallResolveError::TooManyTraitMethods(constraints))
                    } else {
                        // found no candidates
                        if failed_constraints.len() == 1 {
                            return Err(CallResolveError::InvalidTraitMethodCall(failed_constraints.pop().unwrap()))
                        } else if failed_constraints.len() > 1 {
                            return Err(CallResolveError::MultiInvalidTraitMethodCall(failed_constraints));
                        } else {
                            return Err(CallResolveError::NoSuchTraitMethod);
                        }
                    }
                } else {
                    // resolve as a normal method call (with or without trait)
                    infer.change_scope(self.scope);
                    let (mut constraints, mut failed_constraints) = impl_reg.gather_constraints(
                        name, base, &self.args, generic_hints, infer, state, node);
                    if constraints.len() == 1 {
                        // found valid candidate
                        constraints.pop().unwrap()
                    } else if constraints.len() > 1 {
                        // found too many candidates
                        return Err(CallResolveError::TooManyMethods(constraints));
                    } else {
                        // found no candidates
                        if failed_constraints.len() == 1 {
                            return Err(CallResolveError::InvalidMethodCall(failed_constraints.pop().unwrap()));
                        } else if failed_constraints.len() > 1 {
                            return Err(CallResolveError::MultiInvalidMethodCall(failed_constraints));
                        } else {
                            return Err(CallResolveError::NoSuchMethod);
                        }
                    }
                }
            }
            CallType::Function(name) => {
                if let Some(trait_id) = self.trait_id.as_ref() {
                    // resolve as trait function
                    assert_eq!(name.len(), 1);
                    let name = name.first().unwrap();
                    infer.change_scope(self.scope);
                    let (mut constraints, mut failed_constraints) = impl_reg.gather_trait_constraints(
                        trait_id, name, &self.args, generic_hints, infer, state, node);
                    if constraints.len() == 1 {
                        constraints.pop().unwrap()
                    } else if constraints.len() > 1 {
                        // found too many candidates
                        return Err(CallResolveError::TooManyTraitFunctions(constraints))
                    } else {
                        // found no candidates
                        if failed_constraints.len() == 1 {
                            return Err(CallResolveError::InvalidTraitFunctionCall(failed_constraints.pop().unwrap()))
                        } else if failed_constraints.len() > 1 {
                            return Err(CallResolveError::MultiInvalidTraitFunctionCall(failed_constraints));
                        } else {
                            return Err(CallResolveError::NoSuchTraitFunction);
                        }
                    }
                } else {
                    infer.change_scope(self.scope);
                    let Some(s) = infer.name_res().find_top_level_function(name, infer.type_reg()) else {
                        return Err(CallResolveError::NoSuchFunction);
                    };
                    match self.find_function_candidate(s, infer, state, generic_hints, node) {
                        Ok(constraint) => constraint,
                        Err(err) => {
                            return Err(CallResolveError::InvalidFunctionCall(err));
                        }
                    }
                }
            }
        };
        // confirm candidate if only a single candidate was found
        infer.infer_from(state).reinstate(candidate.snapshot);
        self.res = Some(ResolveSuccess {
            sig: candidate.sig,
            fn_id: candidate.id,
            base: candidate.base
        });
        Ok(())
    }

    fn find_function_candidate<I: InferProvider, GenHint: Fn(EdlEnvId, &mut I) -> Result<GenericTypeHints, String>>(
        &self,
        fn_id: EdlTypeId,
        infer: &mut I,
        state: &mut InferState,
        generic_hints: Option<&GenHint>,
        node: NodeId,
    ) -> Result<CallConstraint, FnConstraintError> {
        let mut ctx = infer.infer_from(state);
        let snapshot = ctx.snapshot();

        let sig = roll_back_err!(ctx.type_reg.get_fn_signature(fn_id), ctx, snapshot, fn_id);
        let mut stack = EnvConstraintStack::default();
        let sig_constraint = roll_back_err!(SigConstraint::from_signature(node, fn_id, sig, &mut ctx, &mut stack), ctx, snapshot, fn_id);
        if let Some(hints) = generic_hints {
            let env = sig.env;
            let hints = hints(env, infer)
                .map_err(|err| FnConstraintError::GenericTypeHintError(fn_id, err));
            ctx = infer.infer_from(state);
            let hints = roll_back_err!(hints, ctx, snapshot, fn_id);
            roll_back_err!(sig_constraint.hint_generics(&hints.params, &mut ctx, node), ctx, snapshot, fn_id);
        }
        roll_back_err!(sig_constraint.adapt(node, &self.args.args, &self.args.ret, &mut ctx), ctx, snapshot, fn_id);
        let snapshot = ctx.roll_back_to(snapshot);
        Ok(CallConstraint {
            id: fn_id,
            base: None,
            snapshot,
            sig: sig_constraint,
        })
    }

    pub fn finalize_types(
        &mut self,
        infer: &mut Infer<'_, '_>
    ) -> Option<(EdlTypeId, EdlParamStack, Option<EdlMaybeType>)> {
        let Some(res) = self.res.as_ref() else {
            return None;
        };
        let stack = res.sig.extract_stack(infer);
        // if !stack.is_fully_resolved() {
        //     eprintln!("[WARNING]: stack is not fully resolved! This will most likely result in a compiler panic!");
        //     eprintln!("[WARNING]: {:#?}", res.sig);
        //     eprintln!("[WARNING]: ---");
        // }

        // let base = match &self.base {
        //     CallType::Method(base, _) => Some(infer.find_type(*base)),
        //     CallType::Function(_) => None,
        // };
        let base = if let Some(base) = res.base.as_ref() {
            Some(infer.find_type(*base))
        } else {
            None
        };
        Some((res.fn_id, stack, base))
    }
}
